(function(){
  "use strict";
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (a, b) => a + Math.floor(Math.random() * (b - a + 1));
  const t0 = () => performance.now();
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  function log(msg){
    const el = document.getElementById("log");
    if (!el) return;
    const time = new Date().toLocaleTimeString();
    el.textContent = `[${time}] ${msg}\n` + el.textContent;
  }
  function aria(msg){ const live = document.getElementById("ariaLive"); if (live) live.textContent = msg; }

  class MinHeap { constructor(key = x => x){ this.key = key; this.a = []; } size(){ return this.a.length; } push(v){ this.a.push(v); this._siftUp(this.a.length - 1); } pop(){ if (this.a.length === 0) return undefined; const top = this.a[0]; const last = this.a.pop(); if (this.a.length){ this.a[0] = last; this._siftDown(0); } return top; } peek(){ return this.a[0]; } _parent(i){ return ((i - 1) >> 1); } _left(i){ return (i << 1) + 1; } _right(i){ return (i << 1) + 2; } _siftUp(i){ while (i > 0){ const p = this._parent(i); if (this.key(this.a[i]) < this.key(this.a[p])){ [this.a[i], this.a[p]] = [this.a[p], this.a[i]]; i = p; } else break; } } _siftDown(i){ while (true){ const l = this._left(i), r = this._right(i); let m = i; if (l < this.a.length && this.key(this.a[l]) < this.key(this.a[m])) m = l; if (r < this.a.length && this.key(this.a[r]) < this.key(this.a[m])) m = r; if (m !== i){ [this.a[i], this.a[m]] = [this.a[m], this.a[i]]; i = m; } else break; } } }

  class Cell { constructor(r, c){ this.r = r; this.c = c; this.wall = false; this.weight = 1; this.visited = false; this.frontier = false; this.inPath = false; this.prev = null; this.g = Infinity; this.h = 0; this.f = Infinity; } }

  class Grid {
    constructor(rows, cols){ this.rows = rows; this.cols = cols; this.cells = Array.from({length: rows}, (_, r) => Array.from({length: cols}, (_, c) => new Cell(r,c))); this.start = { r: 2, c: 2 }; this.end = { r: rows - 3, c: cols - 3 }; this.allowDiag = false; }
    inBounds(r,c){ return r >= 0 && r < this.rows && c >= 0 && c < this.cols; }
    neighbors(r,c){ const steps4 = [[1,0],[-1,0],[0,1],[0,-1]]; const steps8 = steps4.concat([[1,1],[1,-1],[-1,1],[-1,-1]]); const S = this.allowDiag ? steps8 : steps4; const out = []; for (const [dr,dc] of S){ const nr = r+dr, nc = c+dc; if (!this.inBounds(nr,nc)) continue; const cell = this.cells[nr][nc]; if (!cell.wall) out.push(cell); } return out; }
    resetStates(){ for (const row of this.cells){ for (const cell of row){ cell.visited = cell.frontier = cell.inPath = false; cell.prev = null; cell.g = Infinity; cell.h = 0; cell.f = Infinity; } } }
    clearAll(){ for (const row of this.cells){ for (const cell of row){ cell.wall = false; cell.weight = 1; cell.visited = cell.frontier = cell.inPath = false; cell.prev = null; cell.g = Infinity; cell.h = 0; cell.f = Infinity; } } }
    toJSON(){ return JSON.stringify({ rows: this.rows, cols: this.cols, start: this.start, end: this.end, allowDiag: this.allowDiag, cells: this.cells.map(row => row.map(c => ({ wall: c.wall, weight: c.weight }))) }, null, 2); }
    static fromJSON(json){ const d = JSON.parse(json); const g = new Grid(d.rows, d.cols); g.start = d.start; g.end = d.end; g.allowDiag = !!d.allowDiag; for (let r=0;r<g.rows;r++){ for (let c=0;c<g.cols;c++){ const s = d.cells[r][c]; const cell = g.cells[r][c]; cell.wall = !!s.wall; cell.weight = s.weight ?? 1; } } return g; }
  }

  const Heur = { manhattan(a,b){ return Math.abs(a.r - b.r) + Math.abs(a.c - b.c); }, euclid(a,b){ const dr=a.r-b.r, dc=a.c-b.c; return Math.hypot(dr,dc); }, chebyshev(a,b){ return Math.max(Math.abs(a.r-b.r), Math.abs(a.c-b.c)); }, };

  function *BFS(grid){ const start = grid.cells[grid.start.r][grid.start.c]; const goal  = grid.cells[grid.end.r][grid.end.c]; const q = [start]; start.visited = true; start.g = 0; let frontierPeak = 1; let visited = 1; while (q.length){ frontierPeak = Math.max(frontierPeak, q.length); const cur = q.shift(); cur.frontier = true; yield {cur, visited, frontierPeak}; if (cur === goal) return {visited, frontierPeak}; for (const nb of grid.neighbors(cur.r, cur.c)){ if (!nb.visited){ nb.visited = true; visited++; nb.prev = cur; q.push(nb); } } cur.frontier = false; } return {visited, frontierPeak}; }
  function *DFS(grid){ const start = grid.cells[grid.start.r][grid.start.c]; const goal  = grid.cells[grid.end.r][grid.end.c]; const st = [start]; start.visited = true; start.g = 0; let frontierPeak = 1; let visited = 1; while (st.length){ frontierPeak = Math.max(frontierPeak, st.length); const cur = st.pop(); cur.frontier = true; yield {cur, visited, frontierPeak}; if (cur === goal) return {visited, frontierPeak}; for (const nb of grid.neighbors(cur.r, cur.c)){ if (!nb.visited){ nb.visited = true; visited++; nb.prev = cur; st.push(nb); } } cur.frontier = false; } return {visited, frontierPeak}; }
  function *Dijkstra(grid){ const start = grid.cells[grid.start.r][grid.start.c]; const goal  = grid.cells[grid.end.r][grid.end.c]; const pq = new MinHeap(n => n.g); start.g = 0; pq.push(start); let frontierPeak = 1; let visited = 0; const seen = new Set(); while (pq.size()){ frontierPeak = Math.max(frontierPeak, pq.size()); const cur = pq.pop(); const key = cur.r+","+cur.c; if (seen.has(key)) continue; seen.add(key); cur.visited = true; visited++; cur.frontier = true; yield {cur, visited, frontierPeak}; if (cur === goal) return {visited, frontierPeak}; for (const nb of grid.neighbors(cur.r, cur.c)){ const w = nb.weight; const ng = cur.g + w * ((nb.r !== cur.r && nb.c !== cur.c) ? Math.SQRT2 : 1); if (ng < nb.g){ nb.g = ng; nb.prev = cur; pq.push(nb); } } cur.frontier = false; } return {visited, frontierPeak}; }
  function *AStar(grid, heuristic){ const start = grid.cells[grid.start.r][grid.start.c]; const goal  = grid.cells[grid.end.r][grid.end.c]; const pq = new MinHeap(n => n.f); start.g = 0; start.h = heuristic(start, goal); start.f = start.g + start.h; pq.push(start); let frontierPeak = 1; let visited = 0; const seen = new Set(); while (pq.size()){ frontierPeak = Math.max(frontierPeak, pq.size()); const cur = pq.pop(); const key = cur.r+","+cur.c; if (seen.has(key)) continue; seen.add(key); cur.visited = true; visited++; cur.frontier = true; yield {cur, visited, frontierPeak}; if (cur === goal) return {visited, frontierPeak}; for (const nb of grid.neighbors(cur.r, cur.c)){ const w = nb.weight; const step = (nb.r !== cur.r && nb.c !== cur.c) ? Math.SQRT2 : 1; const ng = cur.g + w * step; if (ng < nb.g){ nb.g = ng; nb.h = heuristic(nb, goal); nb.f = nb.g + nb.h; nb.prev = cur; pq.push(nb); } } cur.frontier = false; } return {visited, frontierPeak}; }

  function randomScatterWalls(grid, ratio=0.18){ for (const row of grid.cells){ for (const cell of row){ cell.wall = Math.random() < ratio; } } grid.cells[grid.start.r][grid.start.c].wall = false; grid.cells[grid.end.r][grid.end.c].wall = false; }
  function randomWeights(grid, pHeavy=0.25){ for (const row of grid.cells){ for (const cell of row){ cell.weight = Math.random() < pHeavy ? randInt(2,6) : 1; } } grid.cells[grid.start.r][grid.start.c].weight = 1; grid.cells[grid.end.r][grid.end.c].weight = 1; }
  function recursiveDivision(grid){ for (const row of grid.cells){ for (const cell of row){ cell.wall = false; } } function divide(r0, c0, r1, c1){ const h = r1 - r0 + 1; const w = c1 - c0 + 1; if (h < 3 || w < 3) return; const horizontal = h > w; if (horizontal){ const r = r0 + ((randInt(0, Math.floor(h/2)-1)) * 2 + 1); for (let c=c0; c<=c1; c++){ grid.cells[r][c].wall = true; } const hole = c0 + ((randInt(0, Math.floor(w/2)-1)) * 2); grid.cells[r][hole].wall = false; grid.cells[r][hole+1] && (grid.cells[r][hole+1].wall = false); divide(r0, c0, r-1, c1); divide(r+1, c0, r1, c1); } else { const c = c0 + ((randInt(0, Math.floor(w/2)-1)) * 2 + 1); for (let r=r0; r<=r1; r++){ grid.cells[r][c].wall = true; } const hole = r0 + ((randInt(0, Math.floor(h/2)-1)) * 2); grid.cells[hole][c].wall = false; grid.cells[hole+1] && grid.cells[hole+1][c] && (grid.cells[hole+1][c].wall = false); divide(r0, c0, r1, c-1); divide(r0, c+1, r1, c1); } } for (let r=0;r<grid.rows;r++){ grid.cells[r][0].wall = true; grid.cells[r][grid.cols-1].wall = true; } for (let c=0;c<grid.cols;c++){ grid.cells[0][c].wall = true; grid.cells[grid.rows-1][c].wall = true; } divide(1,1, grid.rows-2, grid.cols-2); grid.cells[grid.start.r][grid.start.c].wall = false; grid.cells[grid.end.r][grid.end.c].wall = false; }
  function dfsMaze(grid){ for (const row of grid.cells){ for (const cell of row){ cell.wall = true; } } const stack = []; function isOdd(x){ return x % 2 === 1; } const startR = 1, startC = 1; const inBoundsOdd = (r,c) => r>0 && c>0 && r<grid.rows-1 && c<grid.cols-1 && isOdd(r) && isOdd(c); if (!inBoundsOdd(startR,startC)) return recursiveDivision(grid); grid.cells[startR][startC].wall = false; stack.push([startR,startC]); const dirs = [[2,0],[-2,0],[0,2],[0,-2]]; while (stack.length){ const [r,c] = stack[stack.length-1]; const shuffled = dirs.slice().sort(()=>Math.random()-.5); let carved = false; for (const [dr,dc] of shuffled){ const nr = r+dr, nc = c+dc; if (inBoundsOdd(nr,nc) && grid.cells[nr][nc].wall){ grid.cells[r+dr/2][c+dc/2].wall = false; grid.cells[nr][nc].wall = false; stack.push([nr,nc]); carved = true; break; } } if (!carved) stack.pop(); } grid.cells[grid.start.r][grid.start.c].wall = false; grid.cells[grid.end.r][grid.end.c].wall = false; }

  class Renderer { constructor(host){ this.host = host; this.host.tabIndex = 0; } mount(grid){ this.grid = grid; this.host.style.setProperty('--cols', grid.cols); this.host.innerHTML = ''; const frag = document.createDocumentFragment(); for (let r=0;r<grid.rows;r++){ for (let c=0;c<grid.cols;c++){ const d = document.createElement('div'); d.className = 'cell'; d.dataset.r = r; d.dataset.c = c; d.id = `cell-${r}-${c}`; frag.appendChild(d); } } this.host.appendChild(frag); this.updateAll(); } updateCell(cell){ const d = document.getElementById(`cell-${cell.r}-${cell.c}`); if (!d) return; d.className = 'cell'; if (cell.wall) d.classList.add('wall'); if (cell.visited) d.classList.add('visited'); if (cell.frontier) d.classList.add('frontier'); if (cell.inPath) d.classList.add('path'); if (cell.weight > 1) { d.classList.add('weight'); d.dataset.w = cell.weight; } else { d.classList.remove('weight'); d.removeAttribute('data-w'); } const isStart = (cell.r === this.grid.start.r && cell.c === this.grid.start.c); const isEnd = (cell.r === this.grid.end.r && cell.c === this.grid.end.c); if (isStart) d.classList.add('start'); if (isEnd) d.classList.add('end'); } updateAll(){ for (const row of this.grid.cells){ for (const cell of row){ this.updateCell(cell); } } } showPath(){ let cur = this.grid.cells[this.grid.end.r][this.grid.end.c]; let length = 0; while (cur && cur.prev){ cur.inPath = true; this.updateCell(cur); cur = cur.prev; length++; } return length; } }

  const state = { running: false, stepping: false, tool: 'wall', alg: 'astar', heuristic: 'manhattan', speed: 40, mouseDown: false, dragMode: null, batchPaintLine: false, anchor: null };

  let grid = new Grid(25, 40);
  let view = new Renderer(document.getElementById('grid'));
  view.mount(grid);

  function setPressed(groupSel, value){ for (const b of $$(groupSel)) b.setAttribute('aria-pressed', b.dataset.alg===value || b.dataset.tool===value ? 'true':'false'); }
  setPressed('.alg', state.alg); setPressed('.tool', state.tool);
  $$('.alg').forEach(b=>b.addEventListener('click', ()=>{ state.alg = b.dataset.alg; setPressed('.alg', state.alg); log(`Algorithm: ${state.alg}`);}));
  $$('.tool').forEach(b=>b.addEventListener('click', ()=>{ state.tool = b.dataset.tool; setPressed('.tool', state.tool); log(`Tool: ${state.tool}`);}));

  const statusEl = document.getElementById('status');
  const gridWrap = document.getElementById('gridWrap');
  const gridEl = document.getElementById('grid');
  function setStatus(s){ if(statusEl) statusEl.textContent = s; }
  function setRunning(v){ state.running = v; gridWrap && gridWrap.classList.toggle('running', v); setStatus(v? 'running' : 'idle'); }

  function resizeGrid(rows, cols){ rows = clamp(rows, 10, 60); cols = clamp(cols, 10, 80); const g2 = new Grid(rows, cols); g2.allowDiag = grid.allowDiag; const mr = Math.min(rows, grid.rows), mc = Math.min(cols, grid.cols); for (let r=0;r<mr;r++){ for (let c=0;c<mc;c++){ g2.cells[r][c].wall = grid.cells[r][c].wall; g2.cells[r][c].weight = grid.cells[r][c].weight; } } g2.start = { r: clamp(grid.start.r, 0, rows-1), c: clamp(grid.start.c, 0, cols-1) }; g2.end   = { r: clamp(grid.end.r,   0, rows-1), c: clamp(grid.end.c,   0, cols-1) }; grid = g2; view.mount(grid); const rowsEl = document.getElementById('rows'); const colsEl = document.getElementById('cols'); if (rowsEl) rowsEl.value = rows; if (colsEl) colsEl.value = cols; log(`Grid resized to ${cols} × ${rows}`); }
  const rowsEl = document.getElementById('rows'); const colsEl = document.getElementById('cols'); if (rowsEl) rowsEl.addEventListener('change', e => resizeGrid(parseInt(e.target.value,10), grid.cols)); if (colsEl) colsEl.addEventListener('change', e => resizeGrid(grid.rows, parseInt(e.target.value,10)));

  const themeBtn = document.getElementById('themeBtn'); if (themeBtn) themeBtn.addEventListener('click', ()=>{ const app = document.getElementById('app'); const next = app.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'; app.setAttribute('data-theme', next); });
  const diagEl = document.getElementById('diag'); if (diagEl) diagEl.addEventListener('change', e=>{ grid.allowDiag = e.target.checked; log(`Diagonal: ${grid.allowDiag?'on':'off'}`); });
  const heurEl = document.getElementById('heur'); if (heurEl) heurEl.addEventListener('change', e=>{ state.heuristic = e.target.value; log(`Heuristic: ${state.heuristic}`); });
  const speedEl = document.getElementById('speed'); if (speedEl) speedEl.addEventListener('input', e=>{ state.speed = parseInt(e.target.value,10); });
  function delayMs(){ const t = state.speed / 100; return 5 + Math.round(200 * Math.pow(1 - t, 2)); }

  const exportBtn = document.getElementById('exportBtn'); if (exportBtn) exportBtn.addEventListener('click', ()=>{ const blob = new Blob([grid.toJSON()], {type: 'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'grid.json'; a.click(); URL.revokeObjectURL(url); });
  const importFile = document.getElementById('importFile'); if (importFile) importFile.addEventListener('change', e=>{ const file = e.target.files?.[0]; if (!file) return; const reader = new FileReader(); reader.onload = () => { try { grid = Grid.fromJSON(String(reader.result)); view.mount(grid); log('Imported grid.json'); } catch(err){ alert('Invalid file'); } }; reader.readAsText(file); });

  function paintCell(r,c, mode){ const cell = grid.cells[r][c]; if (!cell) return; const isStart = (r===grid.start.r && c===grid.start.c); const isEnd = (r===grid.end.r && c===grid.end.c); if (mode === 'drag'){ return; } if (mode === 'erase'){ if (!isStart && !isEnd){ cell.wall = false; cell.weight = 1; } } else if (mode === 'wall'){ if (!isStart && !isEnd) cell.wall = true; } else if (mode === 'weight'){ if (!isStart && !isEnd){ cell.wall = false; cell.weight = clamp(cell.weight + 1, 1, 9); if (cell.weight===9) cell.weight = 1; } } view.updateCell(cell); }

  let isMouseDown = false; let paintMode = null; gridEl.addEventListener('mousedown', e=>{ const target = e.target.closest('.cell'); if (!target) return; isMouseDown = true; const r = +target.dataset.r, c = +target.dataset.c; if (r===grid.start.r && c===grid.start.c){ state.dragMode = 'start'; paintMode = 'drag'; } else if (r===grid.end.r && c===grid.end.c){ state.dragMode = 'end'; paintMode = 'drag'; } else { paintMode = state.tool; paintCell(r,c, paintMode); } state.anchor = {r, c}; });
  window.addEventListener('mouseup', ()=>{ isMouseDown = false; state.dragMode = null; state.anchor = null; });
  gridEl.addEventListener('mousemove', e=>{ if (!isMouseDown) return; const target = e.target.closest('.cell'); if (!target) return; const r = +target.dataset.r, c = +target.dataset.c; if (paintMode === 'drag' && state.dragMode){ const old = state.dragMode === 'start' ? grid.start : grid.end; const was = grid.cells[old.r][old.c]; if (was) view.updateCell(was); if (!grid.cells[r][c].wall){ if (state.dragMode === 'start') grid.start = {r,c}; else grid.end = {r,c}; view.updateCell(grid.cells[r][c]); } } else { if (e.ctrlKey || e.metaKey){ const a = state.anchor; if (!a) return paintCell(r,c, paintMode); const line = bresenham(a.r, a.c, r, c); for (const p of line){ paintCell(p.r, p.c, paintMode); } } else { paintCell(r,c, paintMode); } } });
  gridEl.addEventListener('click', e=>{ const target = e.target.closest('.cell'); if (!target) return; if (paintMode === null) { paintMode = state.tool; } const r = +target.dataset.r, c = +target.dataset.c; paintCell(r,c, paintMode); });

  function bresenham(x0,y0,x1,y1){ const points = []; const dx = Math.abs(x1 - x0); const dy = -Math.abs(y1 - y0); const sx = x0 < x1 ? 1 : -1; const sy = y0 < y1 ? 1 : -1; let err = dx + dy; let x = x0; let y = y0; while (true){ points.push({r:x, c:y}); if (x===x1 && y===y1) break; const e2 = 2*err; if (e2 >= dy){ err += dy; x += sx; } if (e2 <= dx){ err += dx; y += sy; } } return points; }

  document.addEventListener('keydown', e=>{ if (e.target.matches('input, select, textarea')) return; if (e.code === 'Space'){ e.preventDefault(); if (state.running) stopRun(); else run(); } if (e.key === 's' || e.key === 'S'){ step(); } if (e.key === 'w' || e.key === 'W'){ state.tool='wall'; setPressed('.tool', state.tool); } if (e.key === 'e' || e.key === 'E'){ state.tool='weight'; setPressed('.tool', state.tool); } if (e.key === 'r' || e.key === 'R'){ state.tool='erase'; setPressed('.tool', state.tool); } if (e.key === 'd' || e.key === 'D'){ state.tool='drag'; setPressed('.tool', state.tool); } if (e.key === '1'){ state.alg='astar'; setPressed('.alg', state.alg); } if (e.key === '2'){ state.alg='dijkstra'; setPressed('.alg', state.alg); } if (e.key === '3'){ state.alg='bfs'; setPressed('.alg', state.alg); } if (e.key === '4'){ state.alg='dfs'; setPressed('.alg', state.alg); } });

  const runBtn = document.getElementById('runBtn'); if (runBtn) runBtn.addEventListener('click', run);
  const stepBtn = document.getElementById('stepBtn'); if (stepBtn) stepBtn.addEventListener('click', step);
  const stopBtn = document.getElementById('stopBtn'); if (stopBtn) stopBtn.addEventListener('click', stopRun);
  const clearBtn = document.getElementById('clearBtn'); if (clearBtn) clearBtn.addEventListener('click', ()=>{ grid.clearAll(); view.updateAll(); stats(0,0,0,0); log('Cleared'); });

  const btnDiv = document.getElementById('mazeDiv'); if (btnDiv) btnDiv.addEventListener('click', ()=>{ recursiveDivision(grid); view.updateAll(); log('Recursive Division maze generated'); });
  const btnDFS = document.getElementById('mazeDFS'); if (btnDFS) btnDFS.addEventListener('click', ()=>{ dfsMaze(grid); view.updateAll(); log('DFS maze generated'); });
  const btnScatter = document.getElementById('scatter'); if (btnScatter) btnScatter.addEventListener('click', ()=>{ randomScatterWalls(grid, 0.18); view.updateAll(); log('Scattered random walls'); });
  const btnWeights = document.getElementById('weights'); if (btnWeights) btnWeights.addEventListener('click', ()=>{ randomWeights(grid, 0.35); view.updateAll(); log('Random weights set'); });

  function stats(visited, frontier, pathLen, runtime){ const vEl = document.getElementById('statVisited'); const fEl = document.getElementById('statFrontier'); const pEl = document.getElementById('statPath'); const rEl = document.getElementById('statRuntime'); if (vEl) vEl.textContent = visited; if (fEl) fEl.textContent = frontier; if (pEl) pEl.textContent = pathLen; if (rEl) rEl.textContent = `${runtime|0} ms`; }

  let iter = null; let lastRuntime = 0; let tickHandle = null;
  function makeIter(){ grid.resetStates(); view.updateAll(); const alg = state.alg; if (alg === 'bfs') return BFS(grid); if (alg === 'dfs') return DFS(grid); if (alg === 'dijkstra') return Dijkstra(grid); const heur = Heur[state.heuristic] || Heur.manhattan; return AStar(grid, heur); }

  function run(){ if (state.running) return; iter = makeIter(); setRunning(true); log('Run start'); const tStart = t0(); const tick = () => { if (!state.running) return; let r; try { r = iter.next(); } catch (e) { log('Error: ' + e.message); setRunning(false); return; } if (r && r.value && r.value.cur){ const { cur, visited, frontierPeak } = r.value; view.updateCell(cur); stats(visited, frontierPeak, 0, performance.now() - tStart); } if (r && r.done){ const len = view.showPath(); lastRuntime = performance.now() - tStart; const v = (r.value || {}); stats(v.visited || 0, v.frontierPeak || 0, len, lastRuntime); log((len>0? 'Done' : 'Done • no path found') + ` • path=${len}, visited=${v.visited||0}, frontierPeak=${v.frontierPeak||0}, ${lastRuntime|0} ms`); setRunning(false); aria('Pathfinding complete'); return; } tickHandle = setTimeout(tick, delayMs()); }; tick(); }

  function stopRun(){ if (!state.running) return; setRunning(false); if (tickHandle) { clearTimeout(tickHandle); tickHandle = null; } log('Stopped'); }

  function step(){ if (!iter || !state.stepping){ iter = makeIter(); state.stepping = true; } const tStart = t0(); const r = iter.next(); if (r.value && r.value.cur){ const { cur, visited, frontierPeak } = r.value; view.updateCell(cur); stats(visited, frontierPeak, 0, performance.now() - tStart); } if (r.done){ const len = view.showPath(); lastRuntime = performance.now() - tStart; const v = (r.value || {}); stats(v.visited || 0, v.frontierPeak || 0, len, lastRuntime); log((len>0? 'Done (step)' : 'Done (step) • no path found') + ` • path=${len}`); state.stepping = false; } }

  recursiveDivision(grid); randomWeights(grid, 0.2); view.updateAll(); log('Ready. Click and drag to edit. Space to run/stop.'); aria('Pathfinding lab ready');
})();
